<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
第四章 密钥，地址，钱包
======
# 简介 #

比特币的拥有证明是基于数字密钥，比特币地址以及数字签名。数字密钥实际上并不存储于网络上，而是由用户创建并以文件或者简单数据库的形式由用户自行保存， 叫做钱包。用户钱包中的数字密钥是完全独立于比特币协议的，它可以由钱包软件创建、管理，而无需与区块链关联或者访问互联网。密钥的存在使比特币的很多特性 得以实现，包括去中心化的信任和控制，持有证明，密码学证明的安全模型等等。

每个比特币交易均需要在在区块链中包含一个有效的签名，这个签名由有效的数字密钥产生，这样，任何一个拥有密钥的人均拥有这个比特币账户中比特币的控制权。 密钥是成对出现的，包含一个私钥（秘密的）和一个公钥。我们可以把公钥想象成一个银行账户的代号，私钥则是这个账户密码，或者支票上用户签名。这些数字密钥 极少被比特币用户看到，实际上，大部分时候，他们存储在钱包文件中，并且由钱包软件进行管理。

在比特币的支付环节，接收者的公钥是由其指纹所代替的，称为比特币地址，它就像支票上的接收人名称（“收款人”）。大多数时候，比特币地址是从私钥产生并与之关联的，但是也可以代表其它“受益人”，比如稍后我们将在本章中将见到的“脚本”。通过这种方式，比特币地址作为接收人的一个抽象表示，使得交易对手更为灵活，类似于纸质支票：一个单一的支付指令既可用于向个人账户付款也可以用于向公司账户付款，既可以账单支付，也可以现金支付。比特币地址是用户可见的唯一表现形式，因为它是需要于公众共享的部分。

在本章中，我们将介绍包含密码学密钥的钱包，我们也将介绍密钥是如何产生，存储和管理的，我们也将看到各种用于公私钥、比特币地址、脚本地址的编码格式；最后，我们将对密钥的特定使用场景、消息签名、所有权证明、创建“炫耀”地址和纸质钱包进行综述。

## 公钥密码学和加密货币

公钥密码学诞生于上世纪70年代，是计算机和信息安全的数学基础。

自公钥密码学发明以来，素数幂、椭圆曲线运算等合适的数学函数路线被发现，这些函数都是不可逆的运算，也就是说，我们很容易从一个方向进行计算得出结果，单色反过来却无法通过结果反向计算得出原文。基于这些数学函数，密码学使得数字密码和不可伪造签名的创建成为可能。比特币使用椭圆曲线运算作为其公钥密码学的基础。

在比特币中，我们利用公钥体系来控制对比特币的访问权。密钥对由私钥和公钥（由私钥派生而来）组成，公钥用于接收比特币，私钥用于对支付比特币的交易进行签名。

在数学上，公私钥间的关系是这样的：私钥用于生成消息签名，公钥在不依赖于私钥的前提下，可以对该签名的有效性进行验证。

当需要支付比特币时，比特币的持有人需要随同交易同时提供公钥和签名（签名每次不同，但都由相同的私钥创建）。通过公钥和签名，比特币网络中的所有参与人都可以验证该笔交易的资金在交易发起时点确实由发起人拥有，由此确认交易的有效性，并接受该笔交易。


![image](https://raw.githubusercontent.com/picocn/furry-potato/alpha/mb/tips.png)*在大部分钱包的实现中，私钥和公钥是存储在一起的，但是由于公钥可以由私钥计算得来，因此只存储私钥也是可行的*


## 私钥和公钥
  一个比特币钱包通常是一系列密钥对的集合，每个密钥对包含一个私钥和一个公钥，私钥(k)，是个数字，通常随机获取。从私钥出发，利用椭圆曲线运算（一种单向加密函数），可以计算得出一个公钥（K），从公钥出发，利用单向密码哈希函数生成比特币地址（A），在本节中，我们从生成私钥开始，接着研究生成公钥的椭圆曲线函数，最后从公钥生成一个比特币地址。

私钥、公钥、比特币地址的关系见下图

```
sequenceDiagram
k->>K: yes
K->>A: yes
A->>K: no
K->>k: no
```

## 私钥
一个私钥就是一串随机生成的数字，拥有和控制私钥是用户控制与比特币地址关联的所有资金的根本。用户交易时需要证明其使用的资金是他自己的，这就需要使用其私钥对交易进行签名，私钥在任何时候军必须保证其私密性，因为将其透露给第三方也就等同于吧对比特币的控制权交给了第三方。私钥同样要进行备份以防意外丢失，如果私钥丢失，将是不可恢复的，受它保护的资金也就彻底丢失了。


![image](https://raw.githubusercontent.com/picocn/furry-potato/alpha/mb/tips.png)*比特币私钥只是一串数字，你甚至可以利用硬币、铅笔和纸张的来随机获取：抛256次硬币，你就拥有了意义用于比特币中使用的私钥的二进制值。生成私钥后，相应的公钥就可以利用私钥计算得出*

### 从一个随机数生成私钥

从随机数生成私钥最关键的一部是找到一个安全的熵源（或者叫随机源），创建比特币秘钥本质上就是取得一个0到2^256之间的数字。如果能保证随机数获取的方式是不可预测、不可重复的，则实际采用哪种方法无关紧要。比特币软件利用操作系统底层的随机数生成器来生成256比特的熵（随机数），通常操作系统的随机数利用一种人工随机源进行初始化，这也是为什么生成的过程中要你随机晃动鼠标几秒钟。对于真正的偏执狂，其实没有什么比骰子、铅笔和纸张更靠谱了。

更确切的说，私钥是从1到n-1之间的任意数字，其中n是一个常量（n=1.158*10^77,比 2^256 略小），在比特币中这个常量是作为椭圆曲线的幂来定义的（参见p65，椭圆曲线密码学解释）。为了生成这样一个密钥，我们随机取一个256比特长度的数字，并验证其是否小于n-1。以程序的术语，这通常是从一个密码学安全的随机源中抽取一长段字符串并填充到SHA256哈希算法中，这样将很方便的生成一个256比特长度的数字。如果上述步骤结果小于n-1，我们就得到了一个合适的私钥。否则，我们只要重复以上步骤最终将得到一个合适的私钥。


![image](https://raw.githubusercontent.com/picocn/furry-potato/alpha/mb/tips.png)*不要试图自己写代码生成密钥或者采用编程语言提供的“简单”的随机数生成器。采用密码学安全的伪随机数生成器（CSPRNG），并且从足够的熵源中提取随机数种子。仔细研究你的随机数生成库的文档，以确定你选择的随机数生成器是密码学安全的。正确选择的CSPRNG算法对于密钥的生成至关重要。*

以下是以十六进制形式表示的随机生成的私钥(k)（256比特的二进制数字用十六进制表示共有64位，每位代表4比特）：
	1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD

![image](https://raw.githubusercontent.com/picocn/furry-potato/alpha/mb/tips.png)*比特币私钥占用的空间，2^256 是一个难以想象的大数，以十进制表示，它大概是10^77， 而可见的宇宙大概是由10^80 个原子构成的*

为了使用比特币的核心客户端创建一个新的密钥，可以使用getnewaddress命令。出于安全考虑，命令输出只显示公钥，私钥不显示。要让bitcoind进程暴露私钥，使用dumpprivkey命令。dumpprivkey命令以"Base58校验和"(Base58 checksum-encoded)编码格式表示密钥，叫做钱包导入格式（Wallet Import Format, WIF)，我们将在P76的“私钥格式”中进一步详细介绍。以下例子展示了利用上述两个命令生成和显示私钥的步骤：
	
	$ bitcoind getnewaddress
	1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
	
	$ bitcoind dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
	KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ

dumpprivkey命令打开钱包并且解压出由getnewaddress生成的私钥。bitcoind是无法通过公钥知道私钥的，除非它们同时存储于钱包中。

![image](https://raw.githubusercontent.com/picocn/furry-potato/alpha/mb/tips.png)*dumpprivkey命令不是从公钥生成一个私钥，因为这根本不可能。这个命令只是简单的从“钱包”中取出由getnewaddress生成的私钥。*

你也可以使用命令行工具sx（参见p56，libbitcoin和sx工具）来生成和展示私钥；相应的sx命令是newkey：

	$ sx newkey
	5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn

##公钥##
公钥是使用椭圆曲线算法从私钥计算得来的，这是一个不可逆的过程:*K=k\*G*，其中，*k*是私钥，*G*是一个常数点（称之为“生成点”）,*K*是计算结果，即公钥。其反向操作被称为“查找离散对数”---已知*K*，求*k*，其难度与尝试所有k可能值的难度差不多，也就是暴力搜索。在我们演示如何从私钥生成公钥之前，我们先更详细的看一下椭圆曲线加密算法。

###椭圆曲线加密算法解释
椭圆曲线加密算法是一种非对称算法，或者叫公钥算法，它的基础是表示为椭圆曲线上点的加法或乘法运算的离散对数问题。

图4-2是一个椭圆曲线的例子，与比特币中使用的类似。

![figure 4-2](fig4-2.png)

*图 4-2 一条椭圆曲线*

比特币使用一个特定的椭圆曲线和一系列数学常量，这些内容在美国国家标准技术研究所（NIST）的secp256k1标准中进行了定义。secp256k1曲线是由以下函数定义的，它构成了一条椭圆曲线：


![equation](http://latex.codecogs.com/gif.latex?y^2=(x^3+7)over(\mathbb{F}_p))

或者

![equation](http://latex.codecogs.com/gif.latex?y^2~\text{mod}~p=(x^3+7)~\text{mod}~p)

*mod p*(对素数p取模）表明，这个曲线是在素数阶p的有限域上，也写成
![equation](http://latex.codecogs.com/gif.latex?\mathbb{F}_p)，其中
![equation](http://latex.codecogs.com/gif.latex?p=2^{256}-2^{32}-2^9-2^8-2^7-2^6-2^4-1)，是一个非常大的素数。

由于这条曲线是基于素数阶而不是基于实数有限域定义的，它的图像看起来像一堆散乱在两个象限上的点，难以形象化。但是它在数学原理上与基于实数的椭圆曲线是一样的。作为一个例子，图4-3显示了一个基于素数阶17（远小于实际值）的有限域上的椭圆曲线，可以看到一系列点散布在网格上。而*secp256k1*比特币椭圆曲线可以想作一个在巨大网格上的更为复杂的散列点。

![figure 4-3](fig4-3.png)

*图 4-3 椭圆曲线密码学：一个在F(p)上的椭圆曲线的图像，其中p=17*

作为例子，以下是一个点P，它的坐标为(x,y)，是一个secpk1曲线上的一个点。可以用Python来进行检验：

	P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)

	Python 3.4.0 (default, Mar 30 2014, 19:23:13)
	[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
	Type "help", "copyright", "credits" or "license" for more information.
	>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
	>>> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
	>>> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
	>>> (x ** 3 + 7 - y**2) % p
	0
	
在椭圆曲线数学中，有个点叫做"无穷远点"，它大致与0在加法中的角色类似。在计算机中，它有时也表示为x=y=0（它不满足椭圆曲线方程，但它是一个简单的可校验的独立案例）。

还有个“+”号运算符，叫做“加法”，它有点类似于小孩子学过的传统实数加法。给定在椭圆曲线上的两个点P1,P2，存在第三个点P3=P1+P2，也在椭圆曲线上。

在几何学上，这个点P3是通过在P1和P2间绘制一条直线来计算的。这条直线将与椭圆曲线相交于一点P3'=(x,y)，通过x轴映射，得到P3=(x,-y).

有很多特殊案例解释了“无穷远点”存在的必要性。

如果P1和P2是同一点，那P1，P2的连接线必然与曲线在P1点相切，曲线有且仅有一个新的点与直线相交。可以使用微积分技术来计算切线的斜率。虽然我们感兴趣的限制到曲线上两个坐标均为整数的点，这些技术仍然能奇怪的满足要求！

在某些情况下（比如：P1和P2的x值相同，但y值不同），切线将是垂直的，则P3=“无穷远点”。

如果P1是无穷远点，那么P1+P2=P2。相应的，如果P2是无穷远点，那么P1+P2=P1。这显示了其与0一样的性质。

事实证明，这里的“+”号符合联合率，也就是说(A+B)C=A(B+C)。这意味着，我们可以不带括号的写A+B+C，而不会有任何歧义。

至此，我们已经定义了加法，我们也可以按照标准的方式通过扩展加法的方式来定义乘法。对于椭圆曲线上的点P，如果k是个整数，那么kP=P+P+p+...+P(k次）。需要注意的是，在这种情况下，k有时也叫做“指数”。

##生成一个公钥
从一个密钥（形式上是一个随机生成的数字k）出发，我们将它与曲线上预定义的点相乘，可以生成曲线上的另一个点，这就是相应的公钥K，而这个预定义的点叫做生成点G。生成点是作为secp256k1标准的一部分定义的，对于比特币而言，其所有密钥均使用相同G点。
	
	K=k*G

这里，k是密钥，G是生成点，K是生成的公钥，椭圆曲线上的一个点。由于生成点对所有比特币用户来说都是一样的，一个密钥k与G相乘后总能得到相同的公钥K。k与K将的关系是固定的，但是只能从k到K单向计算。这也是比特币地址（从K衍生而来）可以与任何人共享，却不会暴露用户私钥（k）的原因。

![notes](notes.png)私钥可以转换为公钥，但是公钥不能转换回私钥，因为数学上，这种计算是单向的。

实现椭圆曲线乘法，我们使用之前生成的私钥k，与生成点G相乘，以获得公钥K：

	K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G

公钥K定义成一个点K=(x,y):

	k=(x,y)
	其中，
	x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
	y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB

为了形象化演示一个点与整数的相乘，我们使用一个简单的基于实数的椭圆曲线--记住，实数与整数曲线数学上是一样的。我们的目标是找到生成点G的倍数kG。也就是G相加k次。在椭圆曲线中，一个点与其自身相加等同于在这个点上画一条切线，找到切斜与曲线相交的点，相交点相对x中对称的点就是我们要找的点。

图 4-4 显示了如何利用几何学操作在曲线上获得G，2G，4G。

![notes](notes.png)大多数比特币实现利用OpenSSL加密库来完成椭圆曲线算法的计算。比如，为了获得公钥，就会用到EC_POINT_mul()函数。

![figure 4-4](fig4-4.png)

*图 4-4 椭圆曲线密码学：演示G在椭圆曲线上被整数k相乘

#比特币地址
比特币地址是一串由数字和字母构成的字符串，可以分享给任何想给你转钱的人。地址是从公钥转换而来的，包含数字和字母，其第一个字符是1（数字）。下面就是一个比特币地址的例子：

	1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy

比特币地址最常见的情况是交易中资金的“接受者”。如果我们将比特币交易与纸质支票做个类比，那么比特币地址就相当于支票上的受益人，也就是我们写入支票“受款人”后的内容。在纸质支票上，受益人可以是一个银行账户持有者的姓名，也可以是公司，机构，甚至现金。由于支票不需要指定账号，只是使用一个抽象的名字作为资金接收人，因此支票作为支付工具非常灵活。比特币交易采用了类似的抽象即比特币地址，使其同样极具灵活性。比特币地址可以指代一个密钥对的拥有者，也可以指代其他一些东西，比如支付脚本，我们将在第132页《支付到脚本哈希（P2SH）》中讲到。现在我们来看一个简单例子，用比特币地址代表公钥以及从公钥衍生比特币地址。

比特币地址是通过一个单项密码学哈希算法从公钥衍生出来的。“哈希算法”是一种单向创建任意长度输入的指纹或者“哈希”的函数。密码学哈希函数在比特币中得到了广泛应用，包括比特币地址，脚本地址，以及挖矿中的工作量证明算法等。用于从公钥创建比特币地址的算法是安全哈希算法（SHA）和RACE完整性原语求值信息摘要(RIPEMD)，特别是SHA256和RIPEMD160。

我们从公钥K开始，计算它的SHA256的哈希值，然后从其结果中计算RIPEMD160的哈希值，这样我们就创建了一个160比特（20字节）长度的数字：

	A = RIPEMD160(SHA256(K))

	其中K是公钥，A是计算结果，即比特币地址

![notes](notes.png)比特币地址与公钥不一样，比特币地址是利用单向哈希函数从公钥衍生得来的。

比特币地址基本上是以Base58Check编码形式展现给用户的，它使用58个字符（一个Base58数字系统）和一个校验码以让人易于阅读，避免歧义，避免地址转录及输入时犯错。第72页有详细的相关Base58和Base58Check编码的说明。为便于用户易于阅读及正确转录数字，Base58Check在比特币中还有很多其他应用，比如比特币地址、用户私钥、加密的密钥、脚本哈希等。在下一节，我们将看到Base58Check的编码和解码机制，以及他们的结果展示。图4-5阐述了从公钥到比特币地址的转换过程。

![figure 4-5](fig4-5.png)

*图 4-5 从公钥到比特币地址：将公钥转换为比特币地址*

##Base58和Base58Check编码
为了采用更少的符号，用更紧凑的方式表示一个很大的数，很多计算机系统使用超过10的进制（底数），并混合字母和数字来表示一个很大的数。举例来说，传统十进制系统使用10个从0到9的数字字符，十六进制系统使用16个字符，包括10个数字字符和A到F 6个字母。一个数采用十六进制表示的话就会比用十进制表示来得短。Base-64编码采用26个小写字母，26个大小字母，10个数字字符，以及额外的两个字符，比如“+”，“/”将二进制数据转换为基于文本的媒体，比如email。Base-64主要用于email中二进制附件的编码。Base58是一个基于文本的二进制编码格式，用于比特币及很多其他密码货币系统中。它在紧凑表示、可读性和错误检测及预防方面提供了一种平衡。Base58是Base64的一个子集，使用大小写字母和数字，但是省略了一些容易混淆的字符。具体来说，Base58是Base64中去掉0(数字零)、O(大写的o)、l(小写的L）、I(大写的i)、字符“+”和字符“/”。或者更简单的说，它是个去掉四个字符（0,O,l,I)的大小写字母与数字的集合。

*例4-1, 比特币的Base58字符表*

	123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

为了增加额外安全性，防止打字和转录错误，常用于比特币的Base58Check编码在Base58编码格式的基础上增加了内置的错误检测码。校验码4个字节长，添加到需要编码的数据后面。校验码从编码后数据的哈希值得到，从而可以检测和避免转录和输入错误。取得一个Base58Check编码的数据后，解码软件可以计算原始数据的校验码，并与数据中的校验码进行比对。如果两者不一致，就说明原始数据有误，Base58Check数据无效。举例来说，这可以避免钱包将输错的比特币地址当做一个有效目标，防止了资金丢失风险。

为了将数据（一个数）转换为Base58Check编码格式，我们首先添加一个前缀到数据中，称之为“版本字节”，这可以让我们更容易判断数据的类型。例如，比特币地址的前缀是0（十六进制表示为0x00），而私钥的前缀为128（十六进制表示为0x80）。常用版本前缀请参看表4-1。

接下来，我们计算“双重SHA”校验码，意思是我们对前面得到的数据（前缀+数据）进行两次SHA256哈希计算：

	checksum = SHA256(SHA256(prefix+data))

从结果的32字节哈希值（哈希的哈希），我们取前面四个字节。这四个字节作为错误检查码，或者校验码附加到数据的最后。

这样，就形成了由三部分（前缀，原始数据，校验码）组成的结果数据。现在可以利用前面介绍的Base58字符表，对结果数据进行编码。图4-6描述了Base58Check的编码过程。

![figure 4-6](fig4-6.png)

*Base58Check编码：一种Base58的，版本化的，可校验的比特币数据无歧义编码格式*

在比特币中，大多数需要向用户展示的数据均以Base58Check格式进行编码，这使得数据紧凑，易读，易于检查错误。Base58Check编码的版本前缀用于创建易于辨别的格式，这意味着，当以Base58编码时，使用Base58Check编码后的数据头部包含了特定的字符。这个字符使用户很容易判断出数据类型，以及如何去使用它。比如，Base58Check编码的比特币地址以1打头，而Base58Check编码的WIF格式私钥以5打头。一些版本前缀的例子，及其编码后的Base58字符见表4-1.

*表4-1 Base58Check版本前缀及编码后结果的举例*

| 类型 | 版本前缀（十六进制） | Base58结果前缀 |
| ---- | ---- | ---- |
| 比特币地址 | 0x00 | 1 |
| 脚本支付地址 | 0x05 | 3 |
| 比特币测试网地址 | 0x6F | m或n |
| 私钥钱包导入格式 | 0x80 | 5, K or L |
| BIP38加密私钥 | 0x0142 6P |
| BIP32扩展公钥 | 0x0488B21E | xpub |

我们来看一下完整的比特币地址生成过程，从私钥到公钥（椭圆曲线上的一个点），到双重哈希的地址，最后Base58Check编码。例4-2的C++代码一步步展示了从私钥一直到Base58Check编码的比特币地址的完整的过程。代码使用了libbitcoin库中的一些函数（第56页《其他替代客户端，库和工具集》中介绍过）

*例4-2 从私钥创建Base58Check编码的比特币地址*

	#include <bitcoin/bitcoin.hpp>
	int main()
	{
		// Private secret key.
		bc::ec_secret secret = bc::decode_hash("038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776");
		// Get public key.
		bc::ec_point public_key = bc::secret_to_public_key(secret);
		std::cout << "Public key: " << bc::encode_hex(public_key) << std::endl;
		// Create Bitcoin address.
		// Normally you can use:
		// bc::payment_address payaddr;
		// bc::set_public_key(payaddr, public_key);
		// const std::string address = payaddr.encoded();
		// Compute hash of public key for P2PKH address.
		const bc::short_hash hash = bc::bitcoin_short_hash(public_key);
		bc::data_chunk unencoded_address;
		// Reserve 25 bytes
		// [ version:1 ]
		// [ hash:20 ]
		// [ checksum:4 ]
		unencoded_address.reserve(25);
		// Version byte, 0 is normal BTC address (P2PKH).
		unencoded_address.push_back(0);
		// Hash data
		bc::extend_data(unencoded_address, hash);
		// Checksum is computed by hashing data, and adding 4 bytes from hash.
		bc::append_checksum(unencoded_address);
		// Finally we must encode the result in Bitcoin's base58 encoding
		assert(unencoded_address.size() == 25);
		const std::string address = bc::encode_base58(unencoded_address);
		std::cout << "Address: " << address << std::endl;
		return 0;
	}

代码使用预定义好的私钥，使得没错运行都可以得到相同的比特币地址，就像例4-3展示的一样：

*例4-3 编译运行这段代码*

	# Compile the addr.cpp code
	$ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin)
	# Run the addr executable
	$ ./addr
	Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa
	Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK

##密钥格式
不管私钥还是公钥都可以表示为一系列不同的格式。这些表现形式均对同样数字进行编码，尽管他们看起来并不一样。这些格式主要用于使用户易于阅读及密钥转录，避免引入错误。

###私钥格式
私钥可以表示为几种不同格式，所有格式均代表与之对应的相同的256比特长的数字。表4-2显示三种用于表示私钥的常用格式。

*表4-2 私钥表示形式（编码格式）

|类型|前缀|说明|
|----|----|----|
|Hex|无|64位十六进制数字|
|WIF|5|Base58Check编码：带128前缀和32比特校验码的Base58编码|
|WIF-compressed|K 或L| 与上面一样，但编码前加一个0x01后缀|

表4-3通过这三种格式展示同一个私钥

*表4-3 例子：相同密钥，不同格式

| 格式 | 私钥 | 
| Hex | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD |
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn |
| WIF-compressed |KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ|

以上这些是用不同格式对相同密钥编码后的展示。虽然看起来不同，但是一种编码格式可以很容易的转换为另一种格式。

###从Base58Check到十六进制解码

使用sx工具包（参看第56页《libbitcoin和sx工具集》）可以让我们很容易写出脚本或者命令行“管道”来操控比特币密钥，地址和交易。你可以使用sx工具集通过命令行来解码Base58Check格式。

我们使用*base58check-decode*命令：

	$ sx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
	1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128

结果是一个十六进制格式的密钥，跟着一个钱包导入格式（WIF）的版本前缀128。

###从十六进制到Base58Check编码

为了编码为Base58Check格式（与前述命令刚好相反），我们提供十六进制的私钥，跟着一个钱包导入格式（WIF）的版本前缀128：

	$ sx base58check-encode	1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128
	5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn

###从十六进制（压缩格式密钥）到Base58Check的编码

为了将“压缩”格式的私钥（参见80页《压缩格式私钥》）编码到Base58Check，我们在十六进制密钥的最后加上后缀01，然后进行编码：

	$ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 128
	KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ

生成的WIF-压缩格式结果以字母“K”开头。这代表私钥带有“01”后缀，并且只可用于生成压缩格式的公钥（参见第78页《压缩格式公钥》）。







	
	
	
