第8章 挖矿与共识
=======

#介绍

挖矿是维持比特币货币供应中的一个过程。同时，挖矿也保护着比特币系统的安全，防止不当交易或者双重支付。即同一笔比特币资金在不同交易里使用。矿工向比特币网络提供处理能力，以交换获取比特币奖励的机会。

矿工验证新的交易，并把它们记录到全局账本上。一个新区块，包含从上个区块以来发生的交易，每隔10分钟左右被“挖”出，从而将这些交易记录到区块链当中。成为区块一部分的交易并被加入区块链的交易被认为是“已确认的”，这使得比特币新的所有者可以花费在这些交易中收到的比特币。

矿工们获得两种类型的挖矿补偿：每个新区块中产生的新比特币；新区块中包含的所有交易的交易费用。为了赢得这些报酬，矿工通过竞争的方式基于密码学哈希算法解决一个极为复杂的数学问题。问题的解称为工作量证明，包含在新区块中，作为矿工付出的显著计算工作量的证明。竞争解决工作量证明算法，赢取奖励以及在区块链上记录交易的权利构成了比特币安全模型的基础。

新比特币产生的过程之所以叫做挖矿，是因为奖励是设计成递减的，就像贵金属的挖矿。比特币的货币供应通过挖矿来实现，类似中央银行通过印钞来发行货币。矿工可以加入区块的新产生比特币数量大概四年（精确的说是每210,000个区块）减少一次。2009年1月比特币网络开始运行的时候每挖出一个区块有50比特币产生，到2012年11月，这个数额减少一半，降为25比特币。到2016年7月（译者：原书为2016年某个时候），已降至12.5比特币每区块。基于这个公式，比特币挖矿奖励以指数级下降一直到大约2140年，所有比特币（20999.99998万）都将被发行完毕。2140后将不会在发行新比特币。

比科比矿工也从交易中赚交易费。每个交易都可能包含有交易费用，交易费用以交易输入和输出金额差值的形式存在。赢得竞争的比特币矿工获得包含在赢得的区块中的所有交易“小费”。目前，交易费用仅占矿工收入的0.5%或更少，主要的收入来源还是新挖出的比特币。但是，随着时间推移，奖励金额不断减少，而每个区块中包含的交易却在增加，交易费用在矿工收入中的占比必将逐步变大。2140年后，由于新比特币枯竭，比特币矿工的收入将全部来自交易费用。

“挖矿”这个词容易让人产生误解。让人想起贵金属挖矿，它将我们的注意力集中到挖矿的奖励上，也就是每个区块产生的新比特币。虽然挖矿是被这些新比特币所激励，挖矿的最主要目的其实不是报酬或者产生新比特币。如果你仅仅将挖矿看做一个创建比特币的过程，你就把手段（激励）当成了此过程的目的。挖矿是去中心化清算所的主要流程，通过清算所，交易被验证和清算。挖矿保护了比特币系统的安全，使得没有中心机构的情况下全网共识得以实现。

挖矿的发明使比特币变成一种特别的货币，而去中心化的安全机制则构成了点对点数字货币的基础。铸币奖励以及交易费用作为一种激励方案，不仅规范了矿工的行为使其符合网络安全的要求，同时也实现了货币的供应。

在本章中，我们首先研究作为货币供应机制的挖矿过程，然后将目光聚焦在其最重要的功能，即：支撑了比特币安全的去中心化共识机制。

#比特币经济学和货币创造

比特币在创建区块的过程中以固定和递减的速率被“铸造”出来。通常每10分钟左右产生一个新的区块，而每个区块均会从无到有产生全新比特币。每经过210,000个区块，或者大约4年，货币发行速率会降低50%。比特币刚开始运作的首个四年，每个区块包含有50个新比特币。

2012年11月，比特币的发行速率降低到了每区块25个比特币，这个过程将继续，到2016年的某个时候，发行速率将降低到每区块12.5比特币（译者：2016年7月已降至12.5比特币）。新比特币的创建速率以这种指数级的方式递减，经过64次“减半”，直到13,230,000号区块被挖出（大致在2137年），每区块创建比特币数量降到货币最小单位1聪。最终，大约到2140年，13.44*10^6个区块被创建后，所有2,099,999,997,690,000聪，或者大约21*10^6个比特币将全部发行完毕。从此以后，区块不再包含新比特币，矿工的报酬将完全来自于交易费用。**图8-1**显示了随着货币发行减少，流通货币与时间的对应关系。

![图8-1](fig8-1.png)

*图8-1 指数递减的发行速率下，比特币货币供应与时间的关系*

在示例代码**例8-1**中，我们计算一下将被发行的所有比特币数量。

*例8-1 计算总共会发行多少比特币的脚本*

    # 最早每个区块奖励给矿工的报酬是50BTC
    start_block_reward = 50
    # 每隔10分钟一个区块，210000个区块约4年
    reward_interval = 210000
    def max_money():
        # 50 BTC = 50 0000 0000 Satoshis
        current_reward = 50 * 10**8
        total = 0
        while current_reward > 0:
        total += reward_interval * current_reward
        current_reward /= 2
        return total
    print "Total BTC to ever be created:" , max_money(), "Satoshis"

**例8-2**展示了脚本运行后的输出结果

*例8-2 运行max_money.py脚本*

    $ python max_money.py
    Total BTC to ever be created: 2099999997690000 Satoshis

有限和递减的发行速度保证了货币供应的稳定性，防止了通货膨胀的发生。不像法币，法币可以被中央银行无限制的印制，比特币不可能因为印制过多而导致通胀。

<table>
<tr>
<th>
通货紧缩的货币
</th>
</tr>
<tr>
<td>
一个固定和递减的货币发行机制的最重要也是最具争议的结果是它天然趋向于*通货紧缩*，通货紧缩是一种价值升值的现象，是因为供应与需求的错配推高了货币的价值（以及兑换汇率）。与通货膨胀相反，价格收水意味着货币随着时间推移拥有了更大的购买力。

很多经济学家认为通缩经济是一场灾难，应不惜任何代价进行避免。因为一段时间内的快速通缩，人民会有价格将继续下降的预期，因此倾向于将钱存起来而不是用于消费。这种现象在日本的“丢失的十年”中得以无情展现，当需求完全瓦解时，也将货币推进了通货紧缩的漩涡。

比特币专家认为通缩本身并不是坏事。当然，通货紧缩是与需求的萎缩相关的，因为这也是我们需要研究的通缩的唯一例子。在一个无限印刷可能性的法币系统中，除非消费需求完全萎缩并且没有印钞欲望，陷入通货紧缩的漩涡是很困难的。比特币中的通缩不是由消费需求萎缩引起的，而是因可预期的货币供应的限制引起的。

在实践中，很明显的，货币通缩导致的储蓄本能可以被供应商打折所抵消，当打折到达一定程度，就可以战胜消费者的储蓄欲望。因为商家一样有储蓄的动机，通过打折最终将达成一个平衡的价格，在这个价格上，双方的储蓄欲望互相匹配达到平衡。只要打折30%，大多数基于比特币的零售商都可以轻松的重新挑起消费者的购物欲望，并获得收益。通缩的货币而不是快速经济萎缩导致的通缩是不是真的问题还有待观察。
</td>
</tr>
</table>

#去中心化共识

在前面章节中，我们观察了区块链，一个包含全部交易的全局公共账本（列表），比特币网络中的所有参与者都可以接受它，并将其视为所有权证明的权威记录。

但是，在不信任任何其他人的情况下，如何让网络中的每个人都能对一个关于谁拥有什么的普遍“真理”取得共识呢？所有传统的支付系统所依赖的信任模型都有一个提供清算服务的中央权威机构，对每一笔交易进行验证并对所有交易进行清算处理。比特币没有中央权威，不过每个完全节点都有一个公共账本的完整拷贝，可以认为是一份权威的记录。区块链不是由中央机构创建的，而是由网络中的每个节点独立组装而成。通过某种方式，网络上的每个节点，基于不安全的网络连接上传输的信息，可以达成一个共同的结论，并且能装配一份与别人完全一样的公共的账本。本章将研究在没有中央机构介入的情况下，比特币如何达成全局共识的过程。

中本聪的发明主要在于建立了一种去中心化的*自发共识（emergent consesus）*机制。自发，是因为共识不是明确达成的--没有选举，也没有一个固定的达成共识的时刻。相反，共识是一种自发的产物，是由成千上万遵循一些简单规则的节点异步交互形成的。所有比特币的属性，包括货币，交易，支付，安全模型均不依赖于中央权威或中央信任，而是从这一发明衍生而来。

比特币的去中心化共识是由四个过程的相互影响而自发产生的，这些过程是网络上的节点独立进行的。

* 基于对规则的完整列表，各个完全节点独立验证每个交易。
* 通过基于工作量证明算法的证明运算，挖矿节点独立将交易汇聚到新区块中。
* 每个区块独立验证新区块并将其整合进区块链。
* 每个节点独立选择累积进行了最多工作量证明计算的链条。

**在接下来的几个小节中，我们将考察这些过程，并且对它们是如何通过交互创建自发的网络属性进行研究，这些属性允许任何比特币节点将网络的权威、信任、公开、全局账本进行组织，形成本地的拷贝，从而形成广泛的共识。**

#独立交易验证

在**第5章*中，我们看到了钱包软件是如何通过收集UTXO，提供合适的解锁脚本，创建指派给新所有者的输出从而创建新交易的。以上过程新建的交易被发送到网络中的邻居节点，从而被广播道整个比特币网络。

但是，将交易转发给邻居前，每个接收到交易的比特币节点首先会验证交易的有效性。这使得只有有效的交易才会在网络中传播，而无效的交易在第一个碰到它的节点就被丢弃了。

每个节点验证交易都要遵守一个长长的规则列表：

* 交易的语法和数据结构必须正确
* 交易的输入和输出均不能为空
* 交易大小字节数必须小于**MAX_BLOCK_SIZE**
* 每个交易输出的汇总价值必须在允许范围内（小于21m比特币，大于0）
* 任何交易输入的哈希不能为0，N不能等于-1（币基交易不能被转发）
* **nLockTime**小于等于**INT_MAX**
* 交易大小字节数必须大于等于100
* 交易中签名操作的数量必须小于签名操作的限制值
* 解锁脚本（**scriptSig**）只能将数字压入堆栈，锁定脚本（**scriptPubKey**)必须匹配**isStandard**格式（这将拒绝“非标准”交易）
* 交易池或者主分支的区块中必须存在匹配的交易
* 对于每个输入，如果引用的输出在交易池的其它交易中存在，交易必须被拒绝
* 对于每个输入，需要在主分支和交易池中查找被引用的输出交易。如果任何输入对应的输出交易不存在，那么这就是个孤儿交易。如果其对应的交易不在孤儿交易池中，将其加入孤儿交易池。
* 对于每个输入，如果引用的输出交易是一个币基输出，必须至少经过**COINBASE_MATURITY(100)**次确认
* 使用输出交易计算输入价值，检查每个输入价值以及汇总值，看其是否超过允许范围（小于21m比特币，大于0）
* 如果输入价值汇总小于输出价值，拒绝
* 如果交易费用太小以致无法加入一个空的区块，拒绝
* 每个输入的解锁脚本必须与相应的输出锁定脚本进行验证

这些条件的细节可以在比特币参考客户端的函数**AcceptToMemoryPool**，**CheckTransaction**,**CheckInput**中看到。注意，这些条件经常变动，添加新约束以防范新类型的拒绝服务攻击，有时也会放松规则以支持新类型的交易。

通过在接收后，发出前独立验证每个交易，每个节点都会创建一个有效新交易的池子（交易池），每个节点交易池中交易的顺序大致相同。



